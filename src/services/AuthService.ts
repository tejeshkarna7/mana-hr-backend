import { User } from '@/models/index.js';
import { IUser, UserStatus } from '@/types/index.js';
import { generateToken, generateRefreshToken, verifyRefreshToken } from '@/utils/jwt.js';
import { generateRandomPassword } from '@/utils/helpers.js';
import MailService from '@/config/mailer.js';
import { AppError } from '@/middlewares/error.js';

export interface LoginResponse {
  user: Omit<IUser, 'password'>;
  token: string;
  refreshToken: string;
}

export interface RegisterData {
  fullName: string;
  email: string;
  phone: string;
  password: string;
  role?: number;
  organization: string;
  organizationCode: string;
}

class AuthService {
  private mailService = MailService.getInstance();

  async register(userData: RegisterData): Promise<LoginResponse> {
    // Check if user already exists
    const existingUser = await User.findOne({ email: userData.email });
    if (existingUser) {
      throw new AppError('User with this email already exists', 400);
    }

    // Check if phone number is already in use
    const existingPhone = await User.findOne({ phone: userData.phone });
    if (existingPhone) {
      throw new AppError('User with this phone number already exists', 400);
    }

    // Create user - employeeCode will be auto-generated by pre-save middleware
    const user = await User.create({
      ...userData,
      status: UserStatus.ACTIVE,
    });

    // Generate tokens
    const token = generateToken(user);
    const refreshToken = generateRefreshToken(user);

    // Update last login
    await user.updateLastLogin();

    return {
      user: user.toObject(),
      token,
      refreshToken,
    };
  }

  async login(email: string, password: string): Promise<LoginResponse> {
    // Find user with password
    const user = await User.findOne({ email }).select('+password +status');
    
    if (!user || !(await user.comparePassword(password))) {
      throw new AppError('Invalid email or password', 401);
    }

    if (user.status !== UserStatus.ACTIVE) {
      throw new AppError('Account is not active', 401);
    }

    // Generate tokens
    const token = generateToken(user);
    const refreshToken = generateRefreshToken(user);

    // Update last login
    await user.updateLastLogin();

    return {
      user: user.toObject(),
      token,
      refreshToken,
    };
  }

  async resetPasswordDirectly(email: string, newPassword: string): Promise<void> {
    const user = await User.findOne({ email });
    
    if (!user) {
      throw new AppError('User not found', 404);
    }

    if (user.status !== UserStatus.ACTIVE) {
      throw new AppError('Account is not active', 401);
    }

    // Hash the new password
    // Note: Password will be hashed by pre-save middleware in User model

    // Update password
    user.password = newPassword;
    await user.save();
  }

  async refreshToken(refreshToken: string): Promise<LoginResponse> {
    // Verify the refresh token
    const payload = verifyRefreshToken(refreshToken);
    
    // Find the user
    const user = await User.findById(payload.userId);
    
    if (!user) {
      throw new AppError('Invalid refresh token', 401);
    }

    if (user.status !== UserStatus.ACTIVE) {
      throw new AppError('Account is not active', 401);
    }

    // Generate new tokens
    const token = generateToken(user);
    const newRefreshToken = generateRefreshToken(user);

    // Update last login
    await user.updateLastLogin();

    return {
      user: user.toObject(),
      token,
      refreshToken: newRefreshToken,
    };
  }

  async getMe(userId: string): Promise<IUser> {
    const user = await User.findById(userId);
    
    if (!user) {
      throw new AppError('User not found', 404);
    }

    return user;
  }

  async createUser(userData: RegisterData, _createdBy: string): Promise<IUser> {
    // Check if user already exists
    const existingUser = await User.findOne({ email: userData.email });
    if (existingUser) {
      throw new AppError('User with this email already exists', 400);
    }

    // Check if phone number is already in use
    const existingPhone = await User.findOne({ phone: userData.phone });
    if (existingPhone) {
      throw new AppError('User with this phone number already exists', 400);
    }

    // Generate temporary password if not provided
    const tempPassword = userData.password || generateRandomPassword();

    // Create user
    const user = await User.create({
      ...userData,
      password: tempPassword,
      status: UserStatus.ACTIVE,
    });

    // Send welcome email with credentials
    if (!userData.password) {
      await this.mailService.sendWelcomeEmail(
        user.email,
        user.fullName,
        tempPassword
      );
    }

    return user;
  }

  async updateUserRole(userId: string, role: number, _updatedBy: string): Promise<IUser> {
    const user = await User.findByIdAndUpdate(
      userId,
      { role },
      { new: true, runValidators: true }
    );

    if (!user) {
      throw new AppError('User not found', 404);
    }

    return user;
  }

  async updateUserStatus(userId: string, status: UserStatus, _updatedBy: string): Promise<IUser> {
    const user = await User.findByIdAndUpdate(
      userId,
      { status },
      { new: true, runValidators: true }
    );

    if (!user) {
      throw new AppError('User not found', 404);
    }

    return user;
  }

  async getAllUsers(page = 1, limit = 10, search?: string, sort?: string): Promise<{
    users: IUser[];
    total: number;
    pages: number;
    currentPage: number;
  }> {
    const skip = (page - 1) * limit;
    
    let query: any = {};
    
    if (search) {
      query = {
        $or: [
          { fullName: { $regex: search, $options: 'i' } },
          { email: { $regex: search, $options: 'i' } },
          { phone: { $regex: search, $options: 'i' } },
        ],
      };
    }

    let sortOption: any = { createdAt: -1 };
    
    if (sort) {
      const [field, order] = sort.split(':');
      sortOption = { [field]: order === 'desc' ? -1 : 1 };
    }

    const [users, total] = await Promise.all([
      User.find(query)
        .sort(sortOption)
        .skip(skip)
        .limit(limit)
        .lean(),
      User.countDocuments(query),
    ]);

    return {
      users,
      total,
      pages: Math.ceil(total / limit),
      currentPage: page,
    };
  }

  async deleteUser(userId: string): Promise<void> {
    const user = await User.findById(userId);
    
    if (!user) {
      throw new AppError('User not found', 404);
    }

    // Don't actually delete, just deactivate
    user.status = UserStatus.INACTIVE;
    await user.save();
  }
}

export default new AuthService();